## Задание

Написать реализацию функции, которая позволит создавать объекты типа Hamburger, используя возможности стандарта ES5.

#### Технические требования:
- Некая сеть фастфудов предлагает два вида гамбургеров:
    - маленький (50 гривен, 20 калорий)
    - большой (100 гривен, 40 калорий)
- Гамбургер должен включать одну дополнительную начинку (обязательно):
    - сыр (+ 10 гривен, + 20 калорий)
    - салат (+ 20 гривен, + 5 калорий)
    - картофель (+ 15 гривен, + 10 калорий)
- Дополнительно, в гамбургер можно добавить приправу (+ 15 гривен, 0 калорий) и полить майонезом (+ 20 гривен, + 5 калорий). 
- Необходимо написать программу, рассчитывающую стоимость и калорийность гамбургера. Обязательно нужно использовать ООП подход (подсказка: нужен класс Гамбургер, константы, методы для выбора опций и рассчета нужных величин).
- Код необходимо написать под стандарт ES5.
- Код должен быть защищен от ошибок. Представьте, что вашим классом будет пользоваться другой программист. Если он передает неправильный тип гамбургера, например, или неправильный вид добавки, должно выбрасываться исключение (ошибка не должна молча игнорироваться).
- Написанный класс должен соответствовать следующему jsDoc описанию (то есть содержать указанные методы, которые принимают и возвращают данные указанного типа и выбрасывают исключения указанного типа. Комментарии ниже тоже можно скопировать в свой код):

   ```javascript
   /**
   * Класс, объекты которого описывают параметры гамбургера. 
   * 
   * @constructor
   * @param size        Размер
   * @param stuffing    Начинка
   * @throws {HamburgerException}  При неправильном использовании
   */
   function Hamburger(size, stuffing) { ... } 
   
   /* Размеры, виды начинок и добавок */
   Hamburger.SIZE_SMALL = ...
   Hamburger.SIZE_LARGE = ...
   Hamburger.STUFFING_CHEESE = ...
   Hamburger.STUFFING_SALAD = ...
   Hamburger.STUFFING_POTATO = ...
   Hamburger.TOPPING_MAYO = ...
   Hamburger.TOPPING_SPICE = ...
   
   /**
   * Добавить добавку к гамбургеру. Можно добавить несколько
   * добавок, при условии, что они разные.
   * 
   * @param topping     Тип добавки
   * @throws {HamburgerException}  При неправильном использовании
   */
   Hamburger.prototype.addTopping = function (topping) ...
   
   /**
    * Убрать добавку, при условии, что она ранее была 
    * добавлена.
    * 
    * @param topping   Тип добавки
    * @throws {HamburgerException}  При неправильном использовании
    */
   Hamburger.prototype.removeTopping = function (topping) ...
   
   /**
    * Получить список добавок.
    *
    * @return {Array} Массив добавленных добавок, содержит константы
    *                 Hamburger.TOPPING_*
    */
   Hamburger.prototype.getToppings = function () ...
   
   /**
    * Узнать размер гамбургера
    */
   Hamburger.prototype.getSize = function () ...
   
   /**
    * Узнать начинку гамбургера
    */
   Hamburger.prototype.getStuffing = function () ...
   
   /**
    * Узнать цену гамбургера
    * @return {Number} Цена в тугриках
    */
   Hamburger.prototype.calculatePrice = function () ...
   
   /**
    * Узнать калорийность
    * @return {Number} Калорийность в калориях
    */
   Hamburger.prototype.calculateCalories = function () ...
   
   /**
    * Представляет информацию об ошибке в ходе работы с гамбургером. 
    * Подробности хранятся в свойстве message.
    * @constructor 
    */
   function HamburgerException (...) { ... }
   ```

#### Комментарии:
- Это задача на ООП. Вам нужно сделать класс, который получает на вход информацию о гамбургере, и на выходе дает информацию о весе и цене. Никакого взаимодействия с пользователем и внешним миром класс делать не должен - все нужные данные ему необходимо передать явно. Он ничего не будет спрашивать, и не будет ничего выводить.
- Почему? Потому что каждый должен заниматься своим делом, класс должен только обсчитывать гамбургер, а вводом-выводом должны заниматься другие части кода. Иначе мы получим кашу, где разные функции смешаны вместе.
- Типы начинок, размеры надо сделать константами. Никаких магических строк не должно быть.
- Переданную информацию о параметрах гамбургера экземпляр класса хранит внутри в своих полях. Вот как может выглядеть использование этого класса:
   
   ```javascript
   // маленький гамбургер с начинкой из сыра
   var hamburger = new Hamburger(Hamburger.SIZE_SMALL, Hamburger.STUFFING_CHEESE);
   // добавка из майонеза
   hamburger.addTopping(Hamburger.TOPPING_MAYO);
   // спросим сколько там калорий
   console.log("Calories: %f", hamburger.calculateCalories());
   // сколько стоит
   console.log("Price: %f", hamburger.calculatePrice());
   // я тут передумал и решил добавить еще приправу
   hamburger.addTopping(Hamburger.TOPPING_SPICE);
   // А сколько теперь стоит? 
   console.log("Price with sauce: %f", hamburger.calculatePrice());
   // Проверить, большой ли гамбургер? 
   console.log("Is hamburger large: %s", hamburger.getSize() === Hamburger.SIZE_LARGE); // -> false
   // Убрать добавку
   hamburger.removeTopping(Hamburger.TOPPING_SPICE);
   console.log("Have %d toppings", hamburger.getToppings().length); // 1
   ```

- При неправильном использовании класс сообщает об этом с помощью выброса исключения.

   ```javascript
   // не передали обязательные параметры
   var h2 = new Hamburger(); // => HamburgerException: no size given
   
   // передаем некорректные значения, добавку вместо размера
   var h3 = new Hamburger(Hamburger.TOPPING_SPICE, Hamburger.TOPPING_SPICE); 
   // => HamburgerException: invalid size 'TOPPING_SAUCE'
   
   // добавляем много добавок
   var h4 = new Hamburger(Hamburger.SIZE_SMALL, Hamburger.STUFFING_CHEESE);
   hamburger.addTopping(Hamburger.TOPPING_MAYO);
   hamburger.addTopping(Hamburger.TOPPING_MAYO); 
   // HamburgerException: duplicate topping 'TOPPING_MAYO'
   
   ```

- В коде выше обратите внимание на такие моменты:
   - класс не взаимодействует с внешним миром. Это не его дело, этим занимается другой код, а класс живет в изоляции от мира
   - обязательные параметры (размер и начинка) мы передаем через конструктор, чтобы нельзя было создать объект, не указав их
   - необязательные (добавка) добавляем через методы
   - имена методов начинаются с глагола и имеют вид «сделайЧтоТо»: calculateCalories(), addTopping()
   - типы начинок обозначены "константами" с понятными именами (на самом деле просто свойствами, написанным заглавными буквами, которые мы договорились считать "константами")
   - об исключительных ситуациях сообщаем с помощью исключений
   - объект создается через конструктор - функцию, которая задает начальные значения полей. Имя конструктора пишется с большой буквы и обычно является существительным: new Hamburger(...)
   - "константы" вроде `Hamburger.SIZE_SMALL` могут иметь значение, являющееся строкой или числом. От смены значения константы ничего не должно меняться (то есть эти значения не должны где-то еще быть записаны). К сожалению, в отличие от других языков (Java, PHP, C#) при опечатке в имени такой "константы" интепретатор JS не укажет на ошибку
   - в свойствах объекта гамбургера логично хранить исходные данные (размер, тип начинки), но не хранить вычисляемые значения (цена, число калорий и т.д.). Рассчитывать цену и калории логично в тот момент, когда это потребуется, а не заранее.
   - в JS нет синтаксиса, чтобы пометить свойство или метод приватным (доступным для использования только внутри класса), потому некоторые разработчики начинают их имена с подчеркивания и договариваются, что извне класса к ним никто не обращается. Вообще, в JS до версии ES6 нет нормальных классов, потому многое основано на таких договоренностях.
- В дополнение, вот еще инструкция, как решать задачи на ООП. Когда ты решаешь задачу на ООП, ты должен ответить на вопросы:
   - какие есть сущности, для которых мы сделаем классы? (Гамбургер).
   - какие у них есть свойства (размер, начинка, добавки). Цена или калории не являются свойствами так как они вычисляются из других свойств и хранить их не надо.
   - что мы хотим от них получить (какие у них должны быть методы). Например, сколько стоит гамбургер?
   - как сущности связаны? У нас одна сущность «Гамбургер» и она ни с чем не связана.
- Заметьте также, что в примере выше класс не взаимодействует с внешним миром. За это отвечает внешний относительно него код. Потому наш класс унивесален: его можно использовать в консоли, выводя данные через console.log, а можно приделать навороченный HTML-интерфейс с кнопками для запуска на планшете с тачскрином. Именно в таком стиле необходимо писать ООП код.
- Классы в JS имитируются ~~всякими костылями~~ разными споcобами, самый общеупотребимый - через добавление методов в прототипы объекта.

#### Литература:
- [ООП в функциональном стиле - Введение](http://learn.javascript.ru/about-oop)
- [Прототип объекта](https://learn.javascript.ru/prototype)
- [Внутренний и внешний интерфейс](http://learn.javascript.ru/internal-external-interface)
- [Перехват ошибок, "try..catch"](http://learn.javascript.ru/exception)
- [throw](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/throw)

Условие задачи взято с [codedokode](https://gist.github.com/codedokode).